{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport { getTreeFromFlatData } from \"react-sortable-tree\";\nconst initialState = {\n  treeData: [],\n  sortTreeData: [],\n  failureModes: []\n};\nconst treeData = createSlice({\n  name: \"treeData\",\n  initialState: initialState,\n  reducers: {\n    addElement(state, action) {\n      state.treeData = [...state.treeData, ...action.payload.data];\n      state.sortTreeData = getTreeFromFlatData({\n        flatData: state.treeData.map(node => ({ ...node,\n          title: node.name\n        })),\n        getKey: node => node.id,\n        // resolve a node's key\n        getParentKey: node => node.parent,\n        // resolve a node's parent's key\n        rootKey: null // The value of the parent key when there is no parent (i.e., at root level)\n\n      });\n    },\n\n    setTreeData(state, action) {\n      state.treeData = action.payload.treeData;\n      state.failureModes = action.payload.failureModes;\n      state.sortTreeData = getTreeFromFlatData({\n        flatData: state.treeData.map(node => ({ ...node,\n          title: node.name\n        })),\n        getKey: node => node.id,\n        // resolve a node's key\n        getParentKey: node => node.parent,\n        // resolve a node's parent's key\n        rootKey: null // The value of the parent key when there is no parent (i.e., at root level)\n\n      });\n    },\n\n    setOnChangeTreeData(state, action) {\n      state.sortTreeData = action.payload.treeData;\n    },\n\n    addChildElement(state, action) {\n      const children = action.payload.children;\n      const parentId = action.payload.parentId;\n      state.treeData = [...state.treeData, ...children];\n      state.treeData.filter(x => x.id === parentId)[0].lmu = 0;\n      state.sortTreeData = getTreeFromFlatData({\n        flatData: state.treeData.map(node => ({ ...node,\n          title: node.name\n        })),\n        getKey: node => node.id,\n        // resolve a node's key\n        getParentKey: node => node.parent,\n        // resolve a node's parent's key\n        rootKey: null // The value of the parent key when there is no parent (i.e., at root level)\n\n      });\n    } //End of reducers\n\n\n  }\n});\nexport const treeDataActions = treeData.actions;\nexport default treeData;","map":{"version":3,"sources":["D:/NetraB/netra/src/store/TreeDataStore.js"],"names":["createSlice","getTreeFromFlatData","initialState","treeData","sortTreeData","failureModes","name","reducers","addElement","state","action","payload","data","flatData","map","node","title","getKey","id","getParentKey","parent","rootKey","setTreeData","setOnChangeTreeData","addChildElement","children","parentId","filter","x","lmu","treeDataActions","actions"],"mappings":"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","sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\r\nimport { getTreeFromFlatData } from \"react-sortable-tree\";\r\n\r\nconst initialState = {\r\n  treeData: [],\r\n  sortTreeData: [],\r\n  failureModes: [],\r\n};\r\n\r\nconst treeData = createSlice({\r\n  name: \"treeData\",\r\n  initialState: initialState,\r\n  reducers: {\r\n    addElement(state, action) {\r\n      state.treeData = [...state.treeData, ...action.payload.data];\r\n      state.sortTreeData = getTreeFromFlatData({\r\n        flatData: state.treeData.map((node) => ({ ...node, title: node.name })),\r\n        getKey: (node) => node.id, // resolve a node's key\r\n        getParentKey: (node) => node.parent, // resolve a node's parent's key\r\n        rootKey: null, // The value of the parent key when there is no parent (i.e., at root level)\r\n      });\r\n    },\r\n    setTreeData(state, action) {\r\n      state.treeData = action.payload.treeData;\r\n      state.failureModes = action.payload.failureModes;\r\n      state.sortTreeData = getTreeFromFlatData({\r\n        flatData: state.treeData.map((node) => ({ ...node, title: node.name })),\r\n        getKey: (node) => node.id, // resolve a node's key\r\n        getParentKey: (node) => node.parent, // resolve a node's parent's key\r\n        rootKey: null, // The value of the parent key when there is no parent (i.e., at root level)\r\n      });\r\n    },\r\n    setOnChangeTreeData(state, action) {\r\n      state.sortTreeData = action.payload.treeData;\r\n    },\r\n    addChildElement(state, action) {\r\n      const children = action.payload.children;\r\n      const parentId = action.payload.parentId;\r\n      state.treeData = [...state.treeData, ...children];\r\n      state.treeData.filter((x) => x.id === parentId)[0].lmu = 0;\r\n      state.sortTreeData = getTreeFromFlatData({\r\n        flatData: state.treeData.map((node) => ({ ...node, title: node.name })),\r\n        getKey: (node) => node.id, // resolve a node's key\r\n        getParentKey: (node) => node.parent, // resolve a node's parent's key\r\n        rootKey: null, // The value of the parent key when there is no parent (i.e., at root level)\r\n      });\r\n    },\r\n    //End of reducers\r\n  },\r\n});\r\n\r\nexport const treeDataActions = treeData.actions;\r\nexport default treeData;\r\n"]},"metadata":{},"sourceType":"module"}