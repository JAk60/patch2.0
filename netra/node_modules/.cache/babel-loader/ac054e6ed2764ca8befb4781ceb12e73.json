{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapConnectorHooks;\n\nvar _react = require('react');\n\nvar _cloneWithRef = require('./utils/cloneWithRef');\n\nvar _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; // When passed a node, call the hook straight away.\n\n    if (!(0, _react.isValidElement)(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options);\n      return undefined;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return (0, _cloneWithRef2.default)(element, ref);\n  };\n}\n\nfunction wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key];\n    var wrappedHook = wrapHookToRecognizeElement(hook);\n\n    wrappedHooks[key] = function () {\n      return wrappedHook;\n    };\n  });\n  return wrappedHooks;\n}","map":{"version":3,"sources":["D:/NETRA -P/Netra/netra/node_modules/react-dnd/lib/wrapConnectorHooks.js"],"names":["Object","defineProperty","exports","value","default","wrapConnectorHooks","_react","require","_cloneWithRef","_cloneWithRef2","_interopRequireDefault","obj","__esModule","throwIfCompositeComponentElement","element","type","displayName","name","Error","wrapHookToRecognizeElement","hook","elementOrNode","arguments","length","undefined","options","isValidElement","node","ref","hooks","wrappedHooks","keys","forEach","key","wrappedHook"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC5CC,EAAAA,KAAK,EAAE;AADqC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,kBAAlB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;;AAEA,IAAIC,aAAa,GAAGD,OAAO,CAAC,sBAAD,CAA3B;;AAEA,IAAIE,cAAc,GAAGC,sBAAsB,CAACF,aAAD,CAA3C;;AAEA,SAASE,sBAAT,CAAgCC,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEP,IAAAA,OAAO,EAAEO;AAAX,GAArC;AAAwD;;AAE/F,SAASE,gCAAT,CAA0CC,OAA1C,EAAmD;AAClD;AACA;AACA,MAAI,OAAOA,OAAO,CAACC,IAAf,KAAwB,QAA5B,EAAsC;AACrC;AACA;;AAED,MAAIC,WAAW,GAAGF,OAAO,CAACC,IAAR,CAAaC,WAAb,IAA4BF,OAAO,CAACC,IAAR,CAAaE,IAAzC,IAAiD,eAAnE;AAEA,QAAM,IAAIC,KAAJ,CAAU,0EAA0E,yBAAyBF,WAAzB,GAAuC,mCAAjH,IAAwJ,sCAAlK,CAAN;AACA;;AAED,SAASG,0BAAT,CAAoCC,IAApC,EAA0C;AACzC,SAAO,YAAY;AAClB,QAAIC,aAAa,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF;AACA,QAAIG,OAAO,GAAGH,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAlF,CAFkB,CAIlB;;AACA,QAAI,CAAC,CAAC,GAAGhB,MAAM,CAACoB,cAAX,EAA2BL,aAA3B,CAAL,EAAgD;AAC/C,UAAIM,IAAI,GAAGN,aAAX;AACAD,MAAAA,IAAI,CAACO,IAAD,EAAOF,OAAP,CAAJ;AACA,aAAOD,SAAP;AACA,KATiB,CAWlB;AACA;AACA;;;AACA,QAAIV,OAAO,GAAGO,aAAd;AACAR,IAAAA,gCAAgC,CAACC,OAAD,CAAhC,CAfkB,CAiBlB;;AACA,QAAIc,GAAG,GAAGH,OAAO,GAAG,UAAUE,IAAV,EAAgB;AACnC,aAAOP,IAAI,CAACO,IAAD,EAAOF,OAAP,CAAX;AACA,KAFgB,GAEbL,IAFJ;AAIA,WAAO,CAAC,GAAGX,cAAc,CAACL,OAAnB,EAA4BU,OAA5B,EAAqCc,GAArC,CAAP;AACA,GAvBD;AAwBA;;AAED,SAASvB,kBAAT,CAA4BwB,KAA5B,EAAmC;AAClC,MAAIC,YAAY,GAAG,EAAnB;AAEA9B,EAAAA,MAAM,CAAC+B,IAAP,CAAYF,KAAZ,EAAmBG,OAAnB,CAA2B,UAAUC,GAAV,EAAe;AACzC,QAAIb,IAAI,GAAGS,KAAK,CAACI,GAAD,CAAhB;AACA,QAAIC,WAAW,GAAGf,0BAA0B,CAACC,IAAD,CAA5C;;AACAU,IAAAA,YAAY,CAACG,GAAD,CAAZ,GAAoB,YAAY;AAC/B,aAAOC,WAAP;AACA,KAFD;AAGA,GAND;AAQA,SAAOJ,YAAP;AACA","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n\tvalue: true\r\n});\r\nexports.default = wrapConnectorHooks;\r\n\r\nvar _react = require('react');\r\n\r\nvar _cloneWithRef = require('./utils/cloneWithRef');\r\n\r\nvar _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction throwIfCompositeComponentElement(element) {\r\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\r\n\t// so that we don't need to depend on findDOMNode() from react-dom.\r\n\tif (typeof element.type === 'string') {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar displayName = element.type.displayName || element.type.name || 'the component';\r\n\r\n\tthrow new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');\r\n}\r\n\r\nfunction wrapHookToRecognizeElement(hook) {\r\n\treturn function () {\r\n\t\tvar elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\r\n\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\r\n\r\n\t\t// When passed a node, call the hook straight away.\r\n\t\tif (!(0, _react.isValidElement)(elementOrNode)) {\r\n\t\t\tvar node = elementOrNode;\r\n\t\t\thook(node, options);\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\r\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\r\n\t\t// are being used under the hood.\r\n\t\tvar element = elementOrNode;\r\n\t\tthrowIfCompositeComponentElement(element);\r\n\r\n\t\t// When no options are passed, use the hook directly\r\n\t\tvar ref = options ? function (node) {\r\n\t\t\treturn hook(node, options);\r\n\t\t} : hook;\r\n\r\n\t\treturn (0, _cloneWithRef2.default)(element, ref);\r\n\t};\r\n}\r\n\r\nfunction wrapConnectorHooks(hooks) {\r\n\tvar wrappedHooks = {};\r\n\r\n\tObject.keys(hooks).forEach(function (key) {\r\n\t\tvar hook = hooks[key];\r\n\t\tvar wrappedHook = wrapHookToRecognizeElement(hook);\r\n\t\twrappedHooks[key] = function () {\r\n\t\t\treturn wrappedHook;\r\n\t\t};\r\n\t});\r\n\r\n\treturn wrappedHooks;\r\n}"]},"metadata":{},"sourceType":"script"}